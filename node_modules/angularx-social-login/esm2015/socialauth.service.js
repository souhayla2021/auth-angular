import { Inject, Injectable } from '@angular/core';
import { AsyncSubject, ReplaySubject } from 'rxjs';
import { GoogleLoginProvider } from './providers/google-login-provider';
/**
 * The service encapsulating the social login functionality. Exposes methods like
 * `signIn`, `signOut`. Also, exposes an `authState` `Observable` that one can
 * subscribe to get the current logged in user information.
 *
 * @dynamic
 */
import * as ɵngcc0 from '@angular/core';
export class SocialAuthService {
    /**
     * @param config A `SocialAuthServiceConfig` object or a `Promise` that resolves to a `SocialAuthServiceConfig` object
     */
    constructor(config) {
        this.providers = new Map();
        this.autoLogin = false;
        this._user = null;
        this._authState = new ReplaySubject(1);
        /* Consider making this an enum comprising LOADING, LOADED, FAILED etc. */
        this.initialized = false;
        this._initState = new AsyncSubject();
        if (config instanceof Promise) {
            config.then((config) => {
                this.initialize(config);
            });
        }
        else {
            this.initialize(config);
        }
    }
    /** An `Observable` that one can subscribe to get the current logged in user information */
    get authState() {
        return this._authState.asObservable();
    }
    /** An `Observable` to communicate the readiness of the service and associated login providers */
    get initState() {
        return this._initState.asObservable();
    }
    initialize(config) {
        this.autoLogin = config.autoLogin !== undefined ? config.autoLogin : false;
        const { onError = console.error } = config;
        config.providers.forEach((item) => {
            this.providers.set(item.id, item.provider);
        });
        Promise.all(Array.from(this.providers.values()).map((provider) => provider.initialize()))
            .then(() => {
            if (this.autoLogin) {
                const loginStatusPromises = [];
                let loggedIn = false;
                this.providers.forEach((provider, key) => {
                    let promise = provider.getLoginStatus();
                    loginStatusPromises.push(promise);
                    promise
                        .then((user) => {
                        user.provider = key;
                        this._user = user;
                        this._authState.next(user);
                        loggedIn = true;
                    })
                        .catch(console.debug);
                });
                Promise.all(loginStatusPromises).catch(() => {
                    if (!loggedIn) {
                        this._user = null;
                        this._authState.next(null);
                    }
                });
            }
        })
            .catch((error) => {
            onError(error);
        })
            .finally(() => {
            this.initialized = true;
            this._initState.next(this.initialized);
            this._initState.complete();
        });
    }
    refreshAuthToken(providerId) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else if (providerId !== GoogleLoginProvider.PROVIDER_ID) {
                reject(SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN);
            }
            else {
                const providerObject = this.providers.get(providerId);
                if (providerObject) {
                    providerObject
                        .getLoginStatus({ refreshToken: true })
                        .then((user) => {
                        user.provider = providerId;
                        this._user = user;
                        this._authState.next(user);
                        resolve();
                    })
                        .catch((err) => {
                        reject(err);
                    });
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    /**
     * A method used to sign in a user with a specific `LoginProvider`.
     *
     * @param providerId Id with which the `LoginProvider` has been registered with the service
     * @param signInOptions Optional `LoginProvider` specific arguments
     * @returns A `Promise` that resolves to the authenticated user information
     */
    signIn(providerId, signInOptions) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else {
                let providerObject = this.providers.get(providerId);
                if (providerObject) {
                    providerObject
                        .signIn(signInOptions)
                        .then((user) => {
                        user.provider = providerId;
                        resolve(user);
                        this._user = user;
                        this._authState.next(user);
                    })
                        .catch((err) => {
                        reject(err);
                    });
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    /**
     * A method used to sign out the currently loggen in user.
     *
     * @param revoke Optional parameter to specify whether a hard sign out is to be performed
     * @returns A `Promise` that resolves if the operation is successful, rejects otherwise
     */
    signOut(revoke = false) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else if (!this._user) {
                reject(SocialAuthService.ERR_NOT_LOGGED_IN);
            }
            else {
                let providerId = this._user.provider;
                let providerObject = this.providers.get(providerId);
                if (providerObject) {
                    providerObject
                        .signOut(revoke)
                        .then(() => {
                        resolve();
                        this._user = null;
                        this._authState.next(null);
                    })
                        .catch((err) => {
                        reject(err);
                    });
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
}
SocialAuthService.ɵfac = function SocialAuthService_Factory(t) { return new (t || SocialAuthService)(ɵngcc0.ɵɵinject('SocialAuthServiceConfig')); };
SocialAuthService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SocialAuthService, factory: SocialAuthService.ɵfac });
SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND = 'Login provider not found';
SocialAuthService.ERR_NOT_LOGGED_IN = 'Not logged in';
SocialAuthService.ERR_NOT_INITIALIZED = 'Login providers not ready yet. Are there errors on your console?';
SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN = 'Chosen login provider is not supported for refreshing a token';
SocialAuthService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['SocialAuthServiceConfig',] }] }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SocialAuthService, [{
        type: Injectable
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: ['SocialAuthServiceConfig']
            }] }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29jaWFsYXV0aC5zZXJ2aWNlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9Vc2Vycy9qZHV0dGEvUHJvamVjdHMvd2ViL2FuZ3VsYXJ4LXNvY2lhbC1sb2dpbi9wcm9qZWN0cy9saWIvc3JjL3NvY2lhbGF1dGguc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQUUsWUFBWSxFQUFjLGFBQWEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUcvRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQVd4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILE1BQU0sT0FBTyxpQkFBaUI7QUFDOUIsSUE0QkU7QUFDRjtBQUNFLE9BQUc7QUFDTCxJQUFFLFlBRUUsTUFBa0U7QUFDbkUsUUExQk8sY0FBUyxHQUErQixJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQzVELFFBQVUsY0FBUyxHQUFHLEtBQUssQ0FBQztBQUM1QixRQUNVLFVBQUssR0FBZSxJQUFJLENBQUM7QUFDbkMsUUFBVSxlQUFVLEdBQThCLElBQUksYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3ZFLFFBQ0UsMEVBQTBFO0FBQzVFLFFBQVUsZ0JBQVcsR0FBRyxLQUFLLENBQUM7QUFDOUIsUUFBVSxlQUFVLEdBQTBCLElBQUksWUFBWSxFQUFFLENBQUM7QUFDakUsUUFrQkksSUFBSSxNQUFNLFlBQVksT0FBTyxFQUFFO0FBQ25DLFlBQU0sTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO0FBQzdCLGdCQUFRLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDaEMsWUFBTSxDQUFDLENBQUMsQ0FBQztBQUNULFNBQUs7QUFBQyxhQUFLO0FBQ1gsWUFBTSxJQUFJLENBQUMsVUFB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QyxLQUFLLEdBQUcsSUFBSSxDQUFDO0FBQ2hDLHdCQUFjLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pDLG9CQUFZLENBQUMsQ0FBQztBQUNkLHlCQUFhLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFO0FBQzNCLHdCQUFjLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUMxQixvQkFBWSxDQUFDLENBQUMsQ0FBQztBQUNmLGlCQUFTO0FBQUMscUJBQUs7QUFDZixvQkFBVSxNQUFNLENBQUMsaUJBQWlCLENBQUMsNEJBQTRCLENBQUMsQ0FBQztBQUNqRSxpQkFBUztBQUNULGFBQU87QUFDUCxRQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ1AsSUFBRSxDQUFDO0FBQ0g7O21IQUFDO0FBMUx5Qiw4Q0FBNEIsR0FDbEQsMEJBQTBCLENBQUM7QUFDTCxtQ0FBaUIsR0FBRyxlQUFlLENBQUM7QUFDcEMscUNBQW1CLEdBQ3pDLGtFQUFrRSxDQUFDO0FBQzdDLHFEQUFtQyxHQUN6RCwrREFBK0QsQ0FBQyxBQVBsRTtBQUFDO0VBREYsVUFBVSxaQUVFLDRDQWdDUixNQUFNLFNBQUMseUJBQXlCO0FBQy9COzs7Ozs7a0NBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQXN5bmNTdWJqZWN0LCBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBMb2dpblByb3ZpZGVyIH0gZnJvbSAnLi9lbnRpdGllcy9sb2dpbi1wcm92aWRlcic7XG5pbXBvcnQgeyBTb2NpYWxVc2VyIH0gZnJvbSAnLi9lbnRpdGllcy9zb2NpYWwtdXNlcic7XG5pbXBvcnQgeyBHb29nbGVMb2dpblByb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlcnMvZ29vZ2xlLWxvZ2luLXByb3ZpZGVyJztcblxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgdG8gZGVmaW5lIHRoZSBzaGFwZSBvZiB0aGUgc2VydmljZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU29jaWFsQXV0aFNlcnZpY2VDb25maWcge1xuICBhdXRvTG9naW4/OiBib29sZWFuO1xuICBwcm92aWRlcnM6IHsgaWQ6IHN0cmluZzsgcHJvdmlkZXI6IExvZ2luUHJvdmlkZXIgfVtdO1xuICBvbkVycm9yPzogKGVycm9yOiBhbnkpID0+IGFueTtcbn1cblxuLyoqXG4gKiBUaGUgc2VydmljZSBlbmNhcHN1bGF0aW5nIHRoZSBzb2NpYWwgbG9naW4gZnVuY3Rpb25hbGl0eS4gRXhwb3NlcyBtZXRob2RzIGxpa2VcbiAqIGBzaWduSW5gLCBgc2lnbk91dGAuIEFsc28sIGV4cG9zZXMgYW4gYGF1dGhTdGF0ZWAgYE9ic2VydmFibGVgIHRoYXQgb25lIGNhblxuICogc3Vic2NyaWJlIHRvIGdldCB0aGUgY3VycmVudCBsb2dnZWQgaW4gdXNlciBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZHluYW1pY1xuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU29jaWFsQXV0aFNlcnZpY2Uge1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFUlJfTE9HSU5fUFJPVklERVJfTk9UX0ZPVU5EID1cbiAgICAnTG9naW4gcHJvdmlkZXIgbm90IGZvdW5kJztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRVJSX05PVF9MT0dHRURfSU4gPSAnTm90IGxvZ2dlZCBpbic7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEVSUl9OT1RfSU5JVElBTElaRUQgPVxuICAgICdMb2dpbiBwcm92aWRlcnMgbm90IHJlYWR5IHlldC4gQXJlIHRoZXJlIGVycm9ycyBvbiB5b3VyIGNvbnNvbGU/JztcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRVJSX05PVF9TVVBQT1JURURfRk9SX1JFRlJFU0hfVE9LRU4gPVxuICAgICdDaG9zZW4gbG9naW4gcHJvdmlkZXIgaXMgbm90IHN1cHBvcnRlZCBmb3IgcmVmcmVzaGluZyBhIHRva2VuJztcblxuICBwcml2YXRlIHByb3ZpZGVyczogTWFwPHN0cmluZywgTG9naW5Qcm92aWRlcj4gPSBuZXcgTWFwKCk7XG4gIHByaXZhdGUgYXV0b0xvZ2luID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfdXNlcjogU29jaWFsVXNlciA9IG51bGw7XG4gIHByaXZhdGUgX2F1dGhTdGF0ZTogUmVwbGF5U3ViamVjdDxTb2NpYWxVc2VyPiA9IG5ldyBSZXBsYXlTdWJqZWN0KDEpO1xuXG4gIC8qIENvbnNpZGVyIG1ha2luZyB0aGlzIGFuIGVudW0gY29tcHJpc2luZyBMT0FESU5HLCBMT0FERUQsIEZBSUxFRCBldGMuICovXG4gIHByaXZhdGUgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfaW5pdFN0YXRlOiBBc3luY1N1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQXN5bmNTdWJqZWN0KCk7XG5cbiAgLyoqIEFuIGBPYnNlcnZhYmxlYCB0aGF0IG9uZSBjYW4gc3Vic2NyaWJlIHRvIGdldCB0aGUgY3VycmVudCBsb2dnZWQgaW4gdXNlciBpbmZvcm1hdGlvbiAqL1xuICBnZXQgYXV0aFN0YXRlKCk6IE9ic2VydmFibGU8U29jaWFsVXNlcj4ge1xuICAgIHJldHVybiB0aGlzLl9hdXRoU3RhdGUuYXNPYnNlcnZhYmxlKCk7XG4gIH1cblxuICAvKiogQW4gYE9ic2VydmFibGVgIHRvIGNvbW11bmljYXRlIHRoZSByZWFkaW5lc3Mgb2YgdGhlIHNlcnZpY2UgYW5kIGFzc29jaWF0ZWQgbG9naW4gcHJvdmlkZXJzICovXG4gIGdldCBpbml0U3RhdGUoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXRTdGF0ZS5hc09ic2VydmFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gY29uZmlnIEEgYFNvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnYCBvYmplY3Qgb3IgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB0byBhIGBTb2NpYWxBdXRoU2VydmljZUNvbmZpZ2Agb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KCdTb2NpYWxBdXRoU2VydmljZUNvbmZpZycpXG4gICAgY29uZmlnOiBTb2NpYWxBdXRoU2VydmljZUNvbmZpZyB8IFByb21pc2U8U29jaWFsQXV0aFNlcnZpY2VDb25maWc+XG4gICkge1xuICAgIGlmIChjb25maWcgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICBjb25maWcudGhlbigoY29uZmlnKSA9PiB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZShjb25maWcpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZShjb25maWcpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaW5pdGlhbGl6ZShjb25maWc6IFNvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnKSB7XG4gICAgdGhpcy5hdXRvTG9naW4gPSBjb25maWcuYXV0b0xvZ2luICE9PSB1bmRlZmluZWQgPyBjb25maWcuYXV0b0xvZ2luIDogZmFsc2U7XG4gICAgY29uc3QgeyBvbkVycm9yID0gY29uc29sZS5lcnJvciB9ID0gY29uZmlnO1xuXG4gICAgY29uZmlnLnByb3ZpZGVycy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICB0aGlzLnByb3ZpZGVycy5zZXQoaXRlbS5pZCwgaXRlbS5wcm92aWRlcik7XG4gICAgfSk7XG5cbiAgICBQcm9taXNlLmFsbChcbiAgICAgIEFycmF5LmZyb20odGhpcy5wcm92aWRlcnMudmFsdWVzKCkpLm1hcCgocHJvdmlkZXIpID0+XG4gICAgICAgIHByb3ZpZGVyLmluaXRpYWxpemUoKVxuICAgICAgKVxuICAgIClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0xvZ2luKSB7XG4gICAgICAgICAgY29uc3QgbG9naW5TdGF0dXNQcm9taXNlcyA9IFtdO1xuICAgICAgICAgIGxldCBsb2dnZWRJbiA9IGZhbHNlO1xuXG4gICAgICAgICAgdGhpcy5wcm92aWRlcnMuZm9yRWFjaCgocHJvdmlkZXI6IExvZ2luUHJvdmlkZXIsIGtleTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IHByb3ZpZGVyLmdldExvZ2luU3RhdHVzKCk7XG4gICAgICAgICAgICBsb2dpblN0YXR1c1Byb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAgIC50aGVuKCh1c2VyOiBTb2NpYWxVc2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgdXNlci5wcm92aWRlciA9IGtleTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3VzZXIgPSB1c2VyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhTdGF0ZS5uZXh0KHVzZXIpO1xuICAgICAgICAgICAgICAgIGxvZ2dlZEluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLmNhdGNoKGNvbnNvbGUuZGVidWcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFByb21pc2UuYWxsKGxvZ2luU3RhdHVzUHJvbWlzZXMpLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIGlmICghbG9nZ2VkSW4pIHtcbiAgICAgICAgICAgICAgdGhpcy5fdXNlciA9IG51bGw7XG4gICAgICAgICAgICAgIHRoaXMuX2F1dGhTdGF0ZS5uZXh0KG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgIH0pXG4gICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9pbml0U3RhdGUubmV4dCh0aGlzLmluaXRpYWxpemVkKTtcbiAgICAgICAgdGhpcy5faW5pdFN0YXRlLmNvbXBsZXRlKCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIHJlZnJlc2hBdXRoVG9rZW4ocHJvdmlkZXJJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX05PVF9JTklUSUFMSVpFRCk7XG4gICAgICB9IGVsc2UgaWYgKHByb3ZpZGVySWQgIT09IEdvb2dsZUxvZ2luUHJvdmlkZXIuUFJPVklERVJfSUQpIHtcbiAgICAgICAgcmVqZWN0KFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9OT1RfU1VQUE9SVEVEX0ZPUl9SRUZSRVNIX1RPS0VOKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyT2JqZWN0ID0gdGhpcy5wcm92aWRlcnMuZ2V0KHByb3ZpZGVySWQpO1xuICAgICAgICBpZiAocHJvdmlkZXJPYmplY3QpIHtcbiAgICAgICAgICBwcm92aWRlck9iamVjdFxuICAgICAgICAgICAgLmdldExvZ2luU3RhdHVzKHsgcmVmcmVzaFRva2VuOiB0cnVlIH0pXG4gICAgICAgICAgICAudGhlbigodXNlcjogU29jaWFsVXNlcikgPT4ge1xuICAgICAgICAgICAgICB1c2VyLnByb3ZpZGVyID0gcHJvdmlkZXJJZDtcbiAgICAgICAgICAgICAgdGhpcy5fdXNlciA9IHVzZXI7XG4gICAgICAgICAgICAgIHRoaXMuX2F1dGhTdGF0ZS5uZXh0KHVzZXIpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX0xPR0lOX1BST1ZJREVSX05PVF9GT1VORCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCB1c2VkIHRvIHNpZ24gaW4gYSB1c2VyIHdpdGggYSBzcGVjaWZpYyBgTG9naW5Qcm92aWRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSBwcm92aWRlcklkIElkIHdpdGggd2hpY2ggdGhlIGBMb2dpblByb3ZpZGVyYCBoYXMgYmVlbiByZWdpc3RlcmVkIHdpdGggdGhlIHNlcnZpY2VcbiAgICogQHBhcmFtIHNpZ25Jbk9wdGlvbnMgT3B0aW9uYWwgYExvZ2luUHJvdmlkZXJgIHNwZWNpZmljIGFyZ3VtZW50c1xuICAgKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHRvIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIgaW5mb3JtYXRpb25cbiAgICovXG4gIHNpZ25Jbihwcm92aWRlcklkOiBzdHJpbmcsIHNpZ25Jbk9wdGlvbnM/OiBhbnkpOiBQcm9taXNlPFNvY2lhbFVzZXI+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTk9UX0lOSVRJQUxJWkVEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwcm92aWRlck9iamVjdCA9IHRoaXMucHJvdmlkZXJzLmdldChwcm92aWRlcklkKTtcbiAgICAgICAgaWYgKHByb3ZpZGVyT2JqZWN0KSB7XG4gICAgICAgICAgcHJvdmlkZXJPYmplY3RcbiAgICAgICAgICAgIC5zaWduSW4oc2lnbkluT3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKCh1c2VyOiBTb2NpYWxVc2VyKSA9PiB7XG4gICAgICAgICAgICAgIHVzZXIucHJvdmlkZXIgPSBwcm92aWRlcklkO1xuICAgICAgICAgICAgICByZXNvbHZlKHVzZXIpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX3VzZXIgPSB1c2VyO1xuICAgICAgICAgICAgICB0aGlzLl9hdXRoU3RhdGUubmV4dCh1c2VyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTE9HSU5fUFJPVklERVJfTk9UX0ZPVU5EKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHVzZWQgdG8gc2lnbiBvdXQgdGhlIGN1cnJlbnRseSBsb2dnZW4gaW4gdXNlci5cbiAgICpcbiAgICogQHBhcmFtIHJldm9rZSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB3aGV0aGVyIGEgaGFyZCBzaWduIG91dCBpcyB0byBiZSBwZXJmb3JtZWRcbiAgICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyBpZiB0aGUgb3BlcmF0aW9uIGlzIHN1Y2Nlc3NmdWwsIHJlamVjdHMgb3RoZXJ3aXNlXG4gICAqL1xuICBzaWduT3V0KHJldm9rZTogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX05PVF9JTklUSUFMSVpFRCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl91c2VyKSB7XG4gICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTk9UX0xPR0dFRF9JTik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJvdmlkZXJJZCA9IHRoaXMuX3VzZXIucHJvdmlkZXI7XG4gICAgICAgIGxldCBwcm92aWRlck9iamVjdCA9IHRoaXMucHJvdmlkZXJzLmdldChwcm92aWRlcklkKTtcbiAgICAgICAgaWYgKHByb3ZpZGVyT2JqZWN0KSB7XG4gICAgICAgICAgcHJvdmlkZXJPYmplY3RcbiAgICAgICAgICAgIC5zaWduT3V0KHJldm9rZSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuXG4gICAgICAgICAgICAgIHRoaXMuX3VzZXIgPSBudWxsO1xuICAgICAgICAgICAgICB0aGlzLl9hdXRoU3RhdGUubmV4dChudWxsKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTE9HSU5fUFJPVklERVJfTk9UX0ZPVU5EKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iXX0=